What I Talk About When I Talk About CLI tool
====

At [YAPC::Asia 2014](http://yapcasia.org/2014/talk/show/b49cc53a-027b-11e4-9357-07b16aeab6a4)

## Agenda

- TL;DR
- なぜCLIツールについて語るのか? (-3min)
- はじめての.sh
    - 使ってもらえるようなツールを作るためには？
- 良いCLIツールとは何か? (5min)
    - 小さい/シンプルである/1つのことに集中している (Keep It Simple, Stupid
    - 直感的に使える(UI/UX
    - 他のツールと連携できる(Play with others)
    - 利用を助けてくれる(Documentation, Usage, man
    - 適切なデフォルト値を持つが，設定もできる(Configurable
    - 苦痛なくインストールできる(Distribution
    - 適切に落ちる(Exceptions
    - すぐに改修できる(Debug, logging    　　　
- 開発の流れ (7min)
    - 自分がCLIをツールを作るなかでこれらをどのように考慮しているのか,
    1. ツールを作るきっかけを得る
    1. 言語を選ぶ
    1. READMEを書く (README driven development)
    1. テスト環境を準備する
    1. 最初のバージョンを作る
    1. リリースする
    1. 宣伝する
- デモ (5min)
    - (できるだけ早く試作する)
    - $ cli-init -s add,delete,list todo
    - $ git this
    - $ git remote add origin
    - $ git push origin master
    - $ go install
    - $ gox -output "pkg/{{.OS}}_{{.Arch}}_{{.Dir}}"
    - $ ghr v0.1.0 pkg
- まとめ

## TL;DR

「良い」CLI(Command Line Interface)ツールを作るために自分が実践していることを語る

「良い」->「使いやすい」->「使ってもらえる」

## なぜCLIツールについて語るのか?

- Webサービスについて語ったものは多いが(開発者がもっとも使う)CLIツールについて語ったものは多くない
- DevOpsツールの登場
- Golangの登場
- 何より自分が大好き

## Warning

- 本トークには個人的な思想がいくつか含まれています
    - 賛同してもらえるところは適用してもらいたい
    - 賛同できない部分はビール飲みながら議論しましょう！

- 本トークにはPerlの話が含まれていません
    - CLIツールはどんな言語でも作れるアプリケーション
        - PerlでもRubyでも，GolangでもBashでも使える話

## 対象オーディエンス

- とにかく何か新しいツールを作り始めたい
  - 作りたいツール，サービスが見つからない
    - webサービスより敷居は低い
      - サーバいらない，DBいらない
- CLIツールを作りたい
- CLIツールを既に作ってるけど，使いやすくしたい

## 僕とCLIツール

- 大学時代にUNIXとの出会い
- 研究で会話ロボットの開発
    - 複雑なシステムを全てCLIで簡単に管理できるようにした
    - たくさんの補助ツールを作った
- Webアプリケーションの開発
    - チームの業務を効率化するためにツールを書いた
- GithubとGolangとの出会い
    - インターネット上のユーザに向けてツールを公開した

- もちろん自分専用のツール自分だけではなく「人に使ってもらう」ことを意識したCLIツールをたくさん作ってきた
- その中で得られた知見について話す

## はじめてのrun.sh

```bash
$ run.sh
```

- 自分だけのタスク効率化スクリプト
    - 開発者なら誰でも一度は書いたことがある
- これを誰かに使ってもらいたい
    - インターネット上の誰か
    - チームメンバー
    - 未来の自分

- もちろん自分だけのために，自分の生活/仕事を楽にするためにツールをつくることは素晴らしい
- どうせ作るなら自分以外のユーザを幸せにしたい
- 自分以外のユーザに「使ってもらえる」ツールを作るには？
- 自分以外のユーザに「便利だ」と思われるようなツールを作るには？

## 良いCLIツールとは何か?

ひとつひとつは当たり前なこと

- 小さい/シンプルである/1つのことに集中している (Keep It Simple, Stupid
    - 多機能にしようとした瞬間に複雑度は一気に増す -> 使いづらさが増す，作りづらさ/バグも増す
        - e.g., コピー    　　
- 直感的に使える(UI/UX
    - iOSにはiOSのAndroidにはAndroidのあるべきUI/UXがあるように
    CLIにもCLIとしてあるべきUI/UXが存在している
        - CLIには長い歴史がある, つまり慣習が存在する -> 慣習から外れない
            - CLIを使っているユーザに違和感を与えない
            - ときには慣習から外れることも必要，ただ僕らが作るほとんどのツールにそれは必要ない
    - コマンドラインパターン
        - <command>
        - <command> <option>
        - <command> <option> <input>
        - <command> <sub-command>
        - <command> <sub-command> <option>
        - <command> <subcommand> <option> <input>
        - cf. なぜvagrant downではないのか？ http://www.msng.info/archives/2013/07/why-not-vagrant-down.php
    - 適切なオプション名
        - 長オプションの意義とは
            - e.g., シェルスクリプトから使われるとする, -dよりも--debugと書いた方がそのシェルスクリプトを読んだ人が理解できる
- 他のツールと連携できる
    - CLIツールは他のツールから呼びだされる可能性が高い
        - e.g. シェルスクリプト
    - 過度の対話インターフェースを避ける
        - 自動化の妨げになる
        - (やりたいのはよくわかるが) 対話処理は最後の手段にする
            - 少なくとも無効果できるようにする
- 利用を助けてくれる (Documentation
    - ドキュメントやUsageが存在しないツールなど誰も使いたくない
    - ユーザのフェーズに合わせたドキュメントを整備する
        - README.md (ツール利用の判断基準のフェーズ)
        - --usage/--help/-h (使ってもらい初めのフェーズ)
        - man (より深く使ってもらうフェーズ)
- 適切なデフォルト値を持つが，設定もできる(Configurable
    - 「n-clickを1-clickにすると商売になる。1-clickを0-clickにすると革命になる」http://www.otsune.com/diary/2008/09/11/1.html
    - 無駄な入力をさせない，取れるものは自動でとる
    - 利用者の思うように設定を変えられるようにする(優先度)
        - デフォルト値 (自動で取得する) （優先度低）
        - 設定ファイル(json，YAML，DSL，hashicorp/hcl)
        - 環境変数
        - コマンドラインオプション（優先度高）
    - 何度も使われることを考慮する (毎回同じことを入力させない)
    - 設定ファイルパターン   　　　　        　　
- 苦痛なくインストールできる(Distribution
    - 使い始めてもらうための障壁をなるべく下げる  　　　
- 適切に落ちる(Exceptions
      - ユーザは意図しない使い方をする -> 例外/エラーのメッセージをそのまま表示しない
          - なぜこのエラーが起きたのかを伝える/どうするべきなのかを伝える
          - e.g.,
- すぐに改修できる(Debug, logging
      - ツールに不具合が起ったときにソースを見なくても何が起ってるのか理解できるように，見るべきソースの場所のあたりをつけられるようにする
      - --debugオプションをツールの開発時から準備する

## 開発の流れ

自分がCLIをツールを作るなかでこれらをどのように考慮しているのか

1. ツールを作るきっかけを得る
    - このタスク複雑すぎる！もっと簡単にしたい, このAPIクライアントなくね？
    - 自分以外の1人以上役に立つと思えば作り始める
    - ただ全く同じものを作るならやめたほうがよい，もったいない
        - 似たようなツールがあるが，これと比べて
        - インターフェースがとてもシンプルだ
        - 速度が速い
1. 言語を選ぶ
    - あらゆるプラットフォームで簡単に使えるものを提供したい
        - Golang
    - 誰でも理解できて修正できるようにしたい（会社のチーム）
        - Bash
            - cf. わかりやすいシェルスクリプトを書く(http://deeeet.com/writing/2014/05/18/shell-template/)
    - Rubyistがたくさん使ってくれそう
        - ruby
    - Perlのひとが...
    - 言語選定はそのまま配布方法と直結する(**苦痛なくインストールできる**)
        - rubyならgemでインストールしたい！
    - もちろん自分が好きな，書きやすい言語を選択するのは重要
1. READMEを書く (README Driven Development)
    - 「やりたいことは本当はすごく沢山あってだけど大体の物は既にあるわけじゃないですか。既にある物に勝つためには優れたアイデアかあと20年続けるモチベーションのどちらかが必要だと思います。」
        - http://weblog.bulknews.net/post/94753348929
        - 似たものは存在する
1. テスト環境を準備する (Test Driven Development)
    - CI as a Service, coveralls.io(テストカバレッジの追跡)の設定をする
    - これらをはじめにやるか，作り終わった後にやるかでテストへのモチベーションが全く変わる
    - そもそもコンパイルが通ってんか？小さいツールなのにテストをがっつり書けと行ってるわけではない
    - 長く続けるならテストは必須．そのpullrequest大丈夫？改修しやすいなどなど
1. 最初のバージョンを作る
    - とにかく動くものをつくる
        - オプションで指定するものは自分が必要な最低限なものだけにしておく
        - オプションで切り替えたいと思うもの，切り替えたいという要望がありそうなものは変数として切り出しておく
    - Usageを書く
    - デバッグオプションを作る
        - 最初から入れる，後から入れるのは本当に面倒
        - デバッグに必要な出力は作ってるときにしかわからない
        - 環境変数($DEBUG)で切り替えられるようにしておく
1. リリースする
    - LL
        - rubygem?
        - CPAN?
        - pip
    - Binary
        - Github release?
        - Bintray.com?
        - Drone.io?
1. 宣伝する
    - あなたのことは誰も知らない
        - Githubにソースを上げるだけでは誰にも見られない
    - 自分のツールの宣伝に時間を使うことに躊躇しない
        - 自信を持ってぶっ込んでいく (README.mdを書いた時点でこのツールは何が優れているのかはっきりしているはず
        - 少しでも誰かに目にしてもらう(フィードバックを貰う，Pull Requestを貰う)
    - 日本語
        - twitterに投稿する
        - hatena bookmarkに投稿する
        - 自分のブログに書く
        - Qiitaに書く
        - 勉強会で発表する
    - 英語
        - coderwallに書く
        - HackerNewsに投稿する
        - MLに投稿する

## デモ (5min)

「できるだけ早く試作する」をGolangでやる

- $ cli-init -s add,delete,list todo
- $ git this
- $ git remote add origin
- $ git push origin master
- $ go install
- $ gox -output "pkg/{{.OS}}_{{.Arch}}_{{.Dir}}"
- $ ghr v0.1.0 pkg

## まとめ

- 小さい/シンプルである/1つのことに集中している (Keep It Simple, Stupid
- 直感的に使える(UI/UX
- 他のツールと連携できる(Play with others)
- 利用を助けてくれる(Documentation, Usage, man
- 適切なデフォルト値を持つが，設定もできる(Configurable
- 苦痛なくインストールできる(Distribution
- 適切に落ちる(Exceptions
- すぐに改修できる(Debug, logging    　　　

## 参考

### UNIX哲学

by Mike Gancarz(マイク・ガンカーズ)

- 小さいものは美しい
- 一つのプログラムには一つのことをうまくやらせる
- できるだけ早く試作する
- 効率より移植性を優先する
- データをフラットなテキストデータとして保存する
- ソフトウェアを梃子（てこ）として使う
- シェルスクリプトによって梃子の効果と移植性を高める
- 過度の対話インターフェースを避ける
- 全てのプログラムをフィルタとして設計する

### UNIXの小定理

- 好みに応じて自分で環境を調整できるようにする
- オペレーティングシステムのカーネルを小さく軽くする
- 小文字を使い，短く
- 木を守る（ドキュメント
- 沈黙は金（エラーメッセージの出力について　　
- 同時に考える（並列処理
- 部分の総和は全体よりも大きい（小さな部品を集めて大きなアプリケーションを作る
- 90パーセントの解を目指す
- 劣る方が優れている
- 階層的に考える

### 「良い」CLIツールとは？

from Build Awesome Command-line tool

- Easy to use
- Helpful
- Play with others
- Has sensible defaults but is configurable
- Install painlessly
- Fails gracefully
- Gets new features and bug fixes easily
- Delights users


### 良いrubyライブラリとは？

by Mitchell Hashimoto
https://speakerdeck.com/mitchellh/building-a-ruby-library-the-parts-no-one-talks-about

- Intuitive API
- Configurable
- Logged
- Exceptions
- Documentation
- Support
