Testable Golang Design
golang.tokyo #2
12 Dec 2016

Taichi Nakashima
@deeeet

* 言いたいこと

依存を明確にせよ！

* whoami

.image img/deeeet.png 200 _

- *@deeeet* / *@tcnksm* (GitHub)
- [[deeeet.com][http://deeeet.com]]
- A PaaS Dev&Ops

* OSS

Tools

- [[https://github.com/tcnksm/gcli][gcli]] - The easy way to build Golang command-line application
- [[https://github.com/tcnksm/ghr][ghr]] - Create Github Release and upload artifacts in parallel

Packages

- [[https://github.com/tcnksm/go-httpstat][go-httpstat]] - Go package for tracing golang HTTP request latency
- [[https://github.com/tcnksm/go-input][go-input]] - Go package for ideal tty prompt
- [[https://github.com/tcnksm/go-latest][go-latest]] - Simple way to check version is latest or not from various sources in Go

* Publications

.image img/minnanoGo.jpg 500 _

.caption [[https://www.amazon.co.jp/dp/477418392X][みんなのGo言語]]

* Testable Golang Design

* テストとは何か?

* テストとは何か?

入力に対して期待する出力が得られているかを確認すること

* テストできない?

1. コードが複雑で新しい機能を追加するのが難しい
2. リファクタリングして見通しの良いコードにしよう
3. リファクタリングのためにはテストが必要だ
4. テストを書くのが難しい...
5. リファクタリングできない...
6. 飲みに行こう🍻

* なぜテストが難しくなってしまうのか?

- 関数の「入力」がコントロールできていない
- 関数の「出力」や「外界への影響（副作用）」を取り出せない
- 外界への依存を抽象化できていない

* テストできないコードはない

- 問題はテストできない設計やデザインである
- 良いテストを書くことは良いコードを書くことと同じである

* Unitテストが大切

.image img/pyramid.png 300 _

.caption [[https://testing.googleblog.com/2015/04/just-say-no-to-more-end-to-end-tests.html][Just Say No to More End-to-End Tests]]

- Unitテストは速い
- Unitテストは信頼できる
- Unitテストは問題を分離できる

* Unitテストが大切

- シンプルなUnitテストをしっかり書く/積み上げることが大切である
- 「基本的で，明らかに正しい関数を組み合わせて，より大きな関数を組み立てる」（「すごいHaskell楽しく学ぼう」）

* 今日の話

何に気をつければTestableなGolangのコードを書けるか（Golangで良いUnitテストを書くにはどうするか）

（自分がやってきたこと/意識してきたことを言語化してきました）

* 今日の話

.image img/tweet.png 400 _


* 絶対に観てほしい！

- [[https://speakerdeck.com/mitchellh/advanced-testing-with-go][Advanced Testing with Go]] by @mitchellh
- [[https://peter.bourgon.org/go-best-practices-2016/][Go best practices, six years in]] by @peterbourgon

* 前提

`testing`パッケージで十分である．フレームワークは使わない．

テストのためのフレームワークを使うことは新たなMini language（DSL）を導入することと変わらない．最初にそれを書く人は楽になるかもしれないが新しくプロジェクトに参入してきたひとにはコストにしかならない（Golang以外も学ぶ必要がある）

[[https://golang.org/doc/faq#Packages_Testing][Where is my favorite helper function for testing?]]

* テストしやすいコードとは?

* Table Driven Test

* Table Driven Test

[[https://github.com/golang/go/wiki/TableDrivenTests][TableDrivenTests]]

.code src/table/simple_test.go /^func Add/,/^}/
.code src/table/simple_test.go /^func Test/,/^}/

* Table Driven Test

なぜTable Driven Testを使うのか?

- 入力が何で出力に何を期待するかを簡単に理解できる
- 簡単にテストケースを追加することができる

Golangでテストを書くときはとにかくTable Driven Testを使う

* Table Driven Test (http.Handler)

.code src/table/handler_test.go /^func hello/,/^}/

* Table Driven Test (http.Handler)

.code src/table/handler_test.go /^func Test/,/^}/

* Table Driven Test (Compiler)

[[https://interpreterbook.com/][Writing An Interpreter In Go]]

.code src/table/compiler_test.go /^func Test/,/^}/

* テストしやすいコードとは?

Table Driven Testに落とし込めるコードである

どれだけ複雑な（複雑に見える）アプリケーションのコードもTable Driven Testの形式/粒度に落とし込むことが大切である

* テストしにくいコードとは?

* テストしにくいコードとは?

- 関数の「入力」がコントロールできていない
- 関数の「出力」や「外界への影響（副作用）」を取り出せない
- 外界への依存を抽象化できていない

* 関数の「入力」がコントロールできていない

入力を変更できない/変更しにくい

- *コード内での入力*
- コード外からの入力

* コントロールできないコード内の入力

- グローバル変数

* グローバル変数

テストしにくい例

.code src/global/bad/main.go /START OMIT/,/END OMIT/

様々な設定ファイルをテストしたい場合にどうすればよいか?

* グローバル変数

テストしやすい例

.code src/global/config.go /^func Load/,/^}/

グローバル変数ではなく引数として明示的に渡す

* グローバル変数

Table Driven Testに落とし込める！

.code src/global/main_test.go /^func Test/,/^}/

* グローバル変数はどこで使うべきか

デフォルト値の設定にのみ利用する．なるべくmain関数でローカル変数に代入する．

.code src/global/main.go /START OMIT/,/END OMIT/

どこでも呼べるとコードの可読性が下がる

* flagどこに定義するか問題

[[https://robots.thoughtbot.com/where-to-define-command-line-flags-in-go][Where to Define Command-Line Flags in Go]]

CLIツールを書くときに`flag`パッケージを主に利用する．`flag.String`や`flag.Int`でフラグを定義して`flag.Parse()`を呼ぶのがRequirementである．どこで定義するべきか?

* flagどこに定義するか問題

良くない例（... が多く見かける）

.code src/global/flag/bad/main.go /START OMIT/,/END OMIT/

なぜ良くないか?（楽しようとして横着するやつが登場するかもしれない）

.code src/global/flag/bad/main.go /^func Future/,/^}/


* flagどこに定義するか問題

良い例（main関数内で定義する）

.code src/global/flag/main.go /^func main/,/^}/

* 入力をコントロールしやすくする

基本的に設定が同じものも変更可能にして「明示的に」入力として渡す

.code src/global/opt/main.go /^type/,/^}/

* 関数の「入力」がコントロールできていない

入力を変更できない/変更しにくい

- コード内での入力
- *コード外からの入力*

* コントロールしにくいコード外からの入力

- 環境変数
- 標準入力
- コマンドライン引数

* 環境変数

良くない例（環境変数はグローバル変数のようにどこからでも取得できてしまう...）

.code src/input/env/bad/client.go /^func/,/^}/

* 環境変数

main関数でローカル変数に代入して明示的に引数として渡す

.code src/input/env/client.go /^func New/,/^}/

.code src/input/env/client.go /^func main/,/^}/

入力の「入り口」を制限する！

* 標準入力

良くない例

.code src/input/stdin/bad/main.go /^func Ask/,/^}/

どうすればこの関数はテストできるようになるか?

* 標準入力

良い例（`io.Reader`を渡す）

.code src/input/stdin/main.go /^func Ask/,/^}/

* 標準入力

良い例（`io.Reader`を渡す）

.code src/input/stdin/main.go /^func main/,/^}/

（`os.Stdin`は`io.Reader`で抽象化できる！）

* 標準入力

Table Driven Testに落とし込める！（`os.Stdin`の代わりに`*bytes.Buffer`を渡す）

.code src/input/stdin/main_test.go /^func Test/,/^}/

* コマンドライン引数

（後述）

* デザインの指標（入力）

- グローバル変数を避ける（使ってもデフォルト値のみで使う）
- なるべく設定可能にして「明示的に」入力として渡せるようにする
- コード外からの入力はmain関数でローカル変数に取り込む（入り口を制限する）
- `os.Stdin`は`io.Reader`で抽象化する

* テストしにくいコードとは?

- 関数の「入力」がコントロールできていない
- *関数の「出力」や「外界への影響（副作用）」を取り出せない*
- 外界への依存を抽象化できていない

* 出力が取り出せない

もっともテストしにくい関数はvoid的な（明確な返り値を持たない）関数である

void的な関数はmainだけにする！

全ての関数が「明確な」入力と出力を持つように意識する

* 出力が取り出せない

「すごいHaskell楽しく学ぼう」より

命令型言語では，一見すると数を処理するだけに見える簡単な関数が処理の手間にあなたの家に火をつけたり犬を誘拐したりしないことを保証できません

Haskellはプログラムの「純粋な」部分と，キーボードや画面とやり取りするような全ての汚い仕事をする「不純な」部分をきっちりと分離します

* 出力が取り出せない

いかに「不純な」部分を扱いテストしやすくするか

- ファイル出力
- 標準出力/標準エラー出力
- 終了コード

* ファイル出力

良くない例

.code src/output/file/bad/main.go /^func SaveConfig/,/^}/

どうすればこの関数はテストしやすくなるか?

* ファイル出力

良い例（実際の書き出しを`io.Writer`に対して行う）

.code src/output/file/main.go /START OMIT/,/END OMIT/

* ファイル出力

Table Driven Testに落とし込める！（*bytes.Bufferを渡す）

.code src/output/file/main_test.go /^func Test/,/^}/

* 標準出力/標準エラー出力

良くない例

.code src/output/stdout/bad/main.go /START OMIT/,/END OMIT/

どうすればこの関数はテストしやすくなるか?

* 標準出力/標準エラー出力

`fmt.Printf`は「暗黙的に」`os.Stdout`を出力先として設定している

    // Printf formats according to a format specifier and writes to standard output.
    // It returns the number of bytes written and any write error encountered.
    func Printf(format string, a ...interface{}) (n int, err error) {
        return Fprintf(os.Stdout, format, a...)
    }

* 標準出力/標準エラー出力

良い例（実際の書き出しを`io.Writer`に対して行う）

.code src/output/stdout/main.go /START OMIT/,/END OMIT/

main関数で`os.Stdout`を「明示的に」設定する

.code src/output/stdout/main.go /^func main/,/^}/

* 標準出力/標準エラー出力

とはいえやりすぎは良くない．コンソールへの出力が重要な機能である場合にやるべき

* 終了コード

良くない例

.code src/output/exit/bad/main.go /^func main/,/^}/

どうすればこの関数はテストできるか?

* 終了コード

（少し）良い例（ステータスコードを「返り値として返す」関数を定義する）

.code src/output/exit/main.go /START OMIT/,/END OMIT/

`os.Exit`はmain関数のみで呼ぶ．出口を制限する！

ただし今のままでは「入力がない」ため`Run`関数をテストできない．どうするか?


* 終了コード + コマンドライン引数

良い例（コマンドライン引数を`Run`関数に渡せるようにする）

.code src/output/exit/args/main.go /START OMIT/,/END OMIT/

* 終了コード + コマンドライン引数 + flag引数

もっと良い例（flag引数をParseする）

.code src/output/exit/flags/main.go /START OMIT/,/END OMIT/

* 終了コード + コマンドライン引数 + flag引数

Table Driven Testに落とし込める！

.code src/output/exit/flags/main_test.go /^func Test/,/^}/

* 終了コード + コマンドライン引数 + flag引数

ただしこれはIntegrationテストに近い．

それよりも内部で呼び出している関数，ここで言うと`process1`や`process2`，のUnitテストをちゃんとやるのが大切である．

* 終了コード

その他の方法

- [[http://mattn.kaoriya.net/software/lang/go/20161025113154.htm][golang で終了を確認するテストの書き方]]

* デザインの指標（出力）

- void的な関数を避ける
- io.Writerを使う！
- main関数で`os.Stdout`/`os.Stdin`を「入力として」渡す
- `os.Exit`はmainでのみ呼ぶ（「出口」を制限する）
- （`os.Args`を引数として渡す）

* テストしにくいコードとは?

- 関数の「入力」がコントロールできていない
- 関数の「出力」や「外界への影響（副作用）」を取り出せない
- *外界への依存を抽象化できていない*

* 外界への依存を抽象化できていない

ある関数は外部のサービスやDBに依存する．それらを常に準備できない場合（e.g., CIサーバー）や準備にコストがかかる場合はテストしにくくなる．

interfaceを使い依存をモック化する．interfaceを使えば「実際の実装」を気にしないで「振る舞い」を渡すことができる．

* interfaceによるモック

良くない例

.code src/interface/bad/main.go /START OMIT/,/END OMIT/

`process`関数はRedisに依存する．Redisなしでテストを行うにはどうすればよいか?

* interfaceによるモック

良い例（`DB`というinterfaceを定義する）

.code src/interface/main.go /^type DB/,/^}/

* interfaceによるモック

良い例（interfaceを引数としてprocessに渡す）

.code src/interface/main.go /START OMIT/,/END OMIT/

* interfaceによるモック

良い例（`DB` interfaceを満たすTestDBを定義する）

.code src/interface/main_test.go /START OMIT/,/END OMIT/

* interfaceによるモック

良い例（テストのときはTestDBをprocessに渡す）

.code src/interface/main_test.go /^func Test/,/^}/

* interfaceによるモック

より良い例（環境変数で実際のDBによるテストとモックによるテストを切り替える）

.code src/interface/better/main_test.go /^func test/,/^}/

コード外で（例えばDockerなどで）Redisが準備できる場合は接続先の情報を環境変数で渡す．

実際のDBでテストを行うことも大切である．

* interface化する利点

interface化にはモック以外の利点もある．例えばRedis以外のDBに切り替えたいときは`DB` interfaceを満たす関数を別途準備するだけで良い．

* デザインの指標（外界の抽象化）

- interfaceを使いモック化を行う

* まとめ

- グローバル変数を避ける（使ってもデフォルト値のみで使う）
- なるべく設定可能にして「明示的に」入力として渡せるようにする
- コード外からの入力はmain関数でローカル変数に取り込む（入り口を制限する）
- `os.Stdin`は`io.Reader`で抽象化する
- void的な関数を避ける
- io.Writerを使う！
- main関数で`os.Stdout`/`os.Stdin`を「入力として」渡す
- `os.Exit`はmainでのみ呼ぶ（「出口」を制限する）
- `os.Args`を引数として渡す
- interfaceを使いモック化を行う

* まとめ

依存を明確にせよ！


* 参考文献1

- [[http://deeeet.com/writing/2016/10/25/go-interface-testing/][Golangにおけるinterfaceをつかったテスト技法]]
- [[http://deeeet.com/writing/2014/12/18/golang-cli-test/][Go言語でテストしやすいコマンドラインツールをつくる]]
- [[https://speakerdeck.com/mitchellh/advanced-testing-with-go][Advanced Testing with Go]] 
- [[https://peter.bourgon.org/go-best-practices-2016/][Go best practices, six years in]]
- [[https://talks.golang.org/2014/testing.slide#1][Testing Techniques]]
- [[https://blog.gopheracademy.com/advent-2015/symmetric-api-testing-in-go/][Symmetric API Testing]] 
- [[https://github.com/peterbourgon/go-microservices][Go + microservices]]
- [[https://medium.com/@benbjohnson/structuring-tests-in-go-46ddee7a25c#.t6pxjnsy0][Structuring Tests in Go]] 
- [[https://nathanleclaire.com/blog/2015/10/10/interfaces-and-composition-for-effective-unit-testing-in-golang/][Interfaces and Composition for Effective Unit Testing in Golang]]
- [[https://interpreterbook.com/][Writing An Interpreter In Go]]
- [[https://robots.thoughtbot.com/where-to-define-command-line-flags-in-go][Where to Define Command-Line Flags in Go]]


* 参考文献2

- [[https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html][The Clean Architecture]]
- [[https://appliedgo.net/di/][The Clean Architecture incl. the Dependency Rule]]
- [[http://manuel.kiessling.net/2012/09/28/applying-the-clean-architecture-to-go-applications/][Applying The Clean Architecture to Go applications]]
- [[http://fideloper.com/hexagonal-architecture][http://fideloper.com/hexagonal-architecture]]
- [[https://dave.cheney.net/2016/08/20/solid-go-design][SOLID Go Design]] [[https://www.youtube.com/watch?v=zzAdEt3xZ1M][video]]
- [[https://changelog.com/gotime/16][Go Time #16: SOLID Go Design with Dave Cheney | Changelog]]
- [[https://www.youtube.com/watch?v=dKRbsE061u4][RubyConf 2009 - SOLID Ruby by: Jim Weirich]]
